<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LSC&#39;s_blog</title>
  <icon>https://www.gravatar.com/avatar/6ce441aa581c6e281c623968a3e3f1d5</icon>
  <subtitle>纯纯的夏季、、纯纯的我们、、那时笑的得多甜~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lsc123.github.io/"/>
  <updated>2019-03-26T15:06:16.274Z</updated>
  <id>https://lsc123.github.io/</id>
  
  <author>
    <name>半盏清酒</name>
    <email>1726947341@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>嵌入式Linux开发笔记 &lt;三&gt;  Linux进程</title>
    <link href="https://lsc123.github.io/2019/03/24/Linux-3/"/>
    <id>https://lsc123.github.io/2019/03/24/Linux-3/</id>
    <published>2019-03-24T13:05:23.000Z</published>
    <updated>2019-03-26T15:06:16.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-进程相关概念"><a href="#1-进程相关概念" class="headerlink" title="1. 进程相关概念"></a>1. 进程相关概念</h2><a id="more"></a><h3 id="1-1程序和进程"><a href="#1-1程序和进程" class="headerlink" title="1.1程序和进程"></a>1.1程序和进程</h3><ul><li>程序： 二进制文件，占用的磁盘空间</li><li>进程： 启动的程序<ul><li>所有的数据都在内存中</li><li>需要占用更多的系统资源（cpu,物理内存），分成若干个时间碎片，给进程处理</li></ul></li></ul><h3 id="1-2并行和并发"><a href="#1-2并行和并发" class="headerlink" title="1.2并行和并发"></a>1.2并行和并发</h3><ul><li>并发：并发并不是一个时间点，而是一个时间段内的概念</li><li>并行：并行是指两个或者多个事件在同一时刻发生</li></ul><h3 id="1-3进程控制块-PCB"><a href="#1-3进程控制块-PCB" class="headerlink" title="1.3进程控制块(PCB)"></a>1.3进程控制块(PCB)</h3><p>　　每一个进程在内核里都有一个进程控制块来维护进程相关的信息。Linux内核的进程控制块是task_struct结构体，在/usr/src/linux-header-3.16/include/linux/sched.h文件里可以查看struct　task_struct结构体的定义，其内部成员有很多，重点掌握以下内容</p><ul><li>进程ID：<br>  　　系统中每个进程都有唯一的ID，在C语言中用pid_t类型表示，其实就是一个非负整数。pid_t是用typedef对某个数据类型做了重定义，后面的_t是就是typedef的意思</li><li>进程的状态：<ul><li>有就绪，允许，运行，挂起，停止等状态</li></ul></li><li>进程切换时需要保存和恢复的一些CPU寄存器</li><li>描述虚拟地址空间的信息<pre><code>  　　在Linux下，每启动一个虚拟进程就对应一个虚拟地址空间，包含应用程序的所有信息，但是里面数据的实际计算是在物理内存里（cpu里的MMU会做一个虚拟内存到物理内存之间的映射）</code></pre></li><li>描述控制终端的信息<pre><code>  　　./a.out执行起来就变成一个进程，进程在运行时，依赖于终端，因为需要把数据输出到对应的终端上，所以进程会保存一些控制终端的信息</code></pre></li><li>当前工作目录（Current Working Directory）<br>  当前进程是在哪个工作目录下工作的<pre class="line-numbers language-bash"><code class="language-bash">  <span class="token function">pwd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>  在Linux下执行pwd,输出当前工作目录，是因为当前工作目录保存在地址空间中</li><li>umask掩码<br>  在每一个进程下都有umask掩码<pre class="line-numbers language-bash"><code class="language-bash">  <span class="token function">umask</span>  <span class="token function">umask</span> 222  <span class="token function">umask</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>  　　使用umask命令查看掩码，使用umask 222 改变进程掩码，在使用umask查看掩码，发现掩码改变为我们过设定的值。当再开启一个进程时，掩码为此进程下的掩码，与刚开始的进程下的修改的掩码不同，每一个进程之间是互不影响的</li><li>文件描述符表，包含很多指向file结构体的指针<br>   　　文件描述符表在pcb里，其实可以看成一个大小为1024数组，对于任何一个进程来说，默认能打开的最多文件个数为1024个，把内核改一下，重新编译一下内核，就可以改变能打开的最多文件个数，不过不建议轻易改动内核，除非特殊需要</li><li>和信号相关的信息<br>   Linux下独有的</li><li>用户ID和组ID<pre class="line-numbers language-bash"><code class="language-bash">  <span class="token function">stat</span> test.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>  输入stat加文件名，查看文件状态uid和Gid后的就是用户ID和组ID</li><li>会话（Session）和进程组<br>   多个进程放在一起就是一个进程组，多个进程组组成的就是会话</li><li>进程可以使用的资源上限（Resource Limit）    <pre class="line-numbers language-bash"><code class="language-bash">  <span class="token function">ulimit</span> -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>  　　输入 ulimit -a命令，可以看到进程里的资源，例如默认能打开的文件个数，管道里的缓存区，栈的默认缓存区大小，都在资源上限里看到，这些数据都是存在进程控制块里，</li></ul><h3 id="1-4进程的五种状态"><a href="#1-4进程的五种状态" class="headerlink" title="1.4进程的五种状态"></a>1.4进程的五种状态</h3><ul><li>就绪态<br>  　　　在终端下执行./a.out后，进程有了，它所对应的地址空间也有了，所处的状态为就绪态，有执行资格，没有执行权，多个进程分用cpu的时间碎片，在没有分到时间碎片时，处于就绪态</li><li>运行态<br>  当抢到时间碎片后，处于运行态，所有的运行态都是从就绪态而来</li><li>挂起态<br>  没有执行资格，没有执行权（例如运行sleep()函数后）</li></ul><p><img src="https://lsc123.github.io/my_picture/Linux_picture/jincheng.png" alt="进程的五种状态"></p><h2 id="2-进程控制"><a href="#2-进程控制" class="headerlink" title="2. 进程控制"></a>2. 进程控制</h2><pre><code>进程控制是讲如何创建子进程</code></pre><h3 id="2-1fork函数"><a href="#2-1fork函数" class="headerlink" title="2.1fork函数"></a>2.1fork函数</h3><p><img src="https://lsc123.github.io/my_picture/Linux_picture/fork.png" alt="fork函数解析"></p><p>　　fork函数创建子进程，子进程相当于父进程的拷贝，用户区数据一样，进程ID不同<br>后续对父进程或子进程用户区数据做操作，互不影响，相互独立<br>　　父进程与子进程的数据在内存区读时共享，写时复制（当就修改的情况下），并且父子进程之间不能够使用全局变量进行通信，因为两个进程之间的内存不能共享</p><ul><li>fork函数有两个返回值<ul><li>父进程返回子进程的PID</li><li>子进程返回0</li></ul></li><li>getpid函数<br>  得到当前进程的PID</li><li>getppid函数<br>  得到当前进程的父进程的PID </li></ul><h4 id="2-1-1父子进程运行先后顺序不一定"><a href="#2-1-1父子进程运行先后顺序不一定" class="headerlink" title="2.1.1父子进程运行先后顺序不一定"></a>2.1.1父子进程运行先后顺序不一定</h4><p><em>通过让父进程sleep(1)来让子进程先运行</em></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" i = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 父进程</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent process, pid = %d, ppid = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//sleep(1);</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 子进程</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child process, pid = %d, ppid = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" i = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　　sleep(1)的作用是让父进程停止一秒，让子进程运行，防止父进程先运行结束，在终端打印时，父进程先运行完后，终端判断从后台运行到前台，此时子进程还未运行结束会出现下面这种输出情况</p><pre class="line-numbers language-bash"><code class="language-bash">执行./a.outi<span class="token operator">=</span>0i<span class="token operator">=</span>1i<span class="token operator">=</span>2i<span class="token operator">=</span>3parent process, ppid <span class="token operator">=</span> 37157lsc@lsc123:~/test $ child process, pid <span class="token operator">=</span>37258 , ppid <span class="token operator">=</span> 37157i<span class="token operator">=</span>0i<span class="token operator">=</span>1i<span class="token operator">=</span>2i<span class="token operator">=</span>3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确输出为</p><pre class="line-numbers language-bash"><code class="language-bash">执行./a.outi<span class="token operator">=</span>0i<span class="token operator">=</span>1i<span class="token operator">=</span>2i<span class="token operator">=</span>3parent process, ppid <span class="token operator">=</span> 37157child process, pid <span class="token operator">=</span>37258 , ppid <span class="token operator">=</span> 37157i<span class="token operator">=</span>0i<span class="token operator">=</span>1i<span class="token operator">=</span>2i<span class="token operator">=</span>3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2验证父子进程间是否共享全局变量"><a href="#2-1-2验证父子进程间是否共享全局变量" class="headerlink" title="2.1.2验证父子进程间是否共享全局变量"></a>2.1.2验证父子进程间是否共享全局变量</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 父进程</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        counter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent process, pid = %d, ppid = %d, %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//        sleep(1);</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 子进程</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1th</span>        counter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child process, pid = %d, ppid = %d, %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 2th</span>        counter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child process, pid = %d, ppid = %d, %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 3th</span>        counter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child process, pid = %d, ppid = %d, %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-3-例程-验证父子进程间使用文件进行通信"><a href="#2-1-3-例程-验证父子进程间使用文件进行通信" class="headerlink" title="2.1.3 例程-验证父子进程间使用文件进行通信"></a>2.1.3 例程-验证父子进程间使用文件进行通信</h4><p>　　父进程内核区有一个pcb,pcb中有一个文件描述符表，文件描述符表中含有1024个文件描述符，前三个被占用（0-2 stdin,stdout,stderr），在父进程中的3号文件描述符指向创建的temp文件，执行一个fork操作，创建一个子进程，除了进程ID不同，其余与父进程相同，子进程的文件描述符表同样与父进程相同，因此子进程的3号文件描述符也指向了temp文件</p><p>1.打开一个temp文件，如果没有就创建一个<br>2.创建一个子进程<br>3.向父进程中写入一段数据，并关闭父进程<br>4.子进程睡1s保证父进程已经完成了文件的写操作<br>5.temp文件只要吧被父子进程中的一个文件描述符占用，temp里的文件指针就不会移动到头部，因此需要使用lseek()函数将文件指针移动到头部,保证数据能够读出来<br>6.把文件里数据读到buf[]组中，输出出来</p><p><strong><em>如果能将子进程能读出父进程写入的数据并打印出来，则说明父子进程间可以使用文件进行通信</em></strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token comment" spellcheck="true">// 操作终端文件　/dev/tty默认阻塞</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"temp"</span><span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">,</span> <span class="token number">0664</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token string">"近期，微软向Linux开发人员伸出了橄榄枝，希望Linux开发人员能够转移到Windows 10平台上进行开发。"</span><span class="token punctuation">;</span>        <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> p<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 睡1s保证父进程已经完成了文件的写操作</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SEEK_SET<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">gcc process_file.c./a.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-1-4-例程-父进程fork三个子进程"><a href="#2-1-4-例程-父进程fork三个子进程" class="headerlink" title="2.1.4 例程-父进程fork三个子进程"></a>2.1.4 例程-父进程fork三个子进程</h4><pre><code>父进程fork三个子进程其中一个调用ps命令;一个调用自定义应用程序;一个调用会出现段错误的程序。父进程回收三个子进程(waitpid)，并且打印三个子进程的退出状态。</code></pre><p>　　当发生了段错误以后，系统会执行11号信号SIGSEGV（输入kill -l 命令可以查看）,11号信号就是段错误的意思，假设写的应用程序满足了段错误的条件，内核就会给应用程序发一个11号信号，当应用程序收到11号程序，程序就会结束</p><pre><code>=== 段错误 ===    1. 访问了非法内存    2. 访问了不可写的区域进行写操作    3. 栈空间溢出   </code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pid_t pid<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"ps"</span><span class="token punctuation">,</span> <span class="token string">"ps"</span><span class="token punctuation">,</span> <span class="token string">"aux"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execlp ps"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/home/kevin/test/app"</span><span class="token punctuation">,</span> <span class="token string">"app"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execl app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"./error"</span><span class="token punctuation">,</span> <span class="token string">"error"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行段错误应用程序</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execl error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> num<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 回收</span>        <span class="token keyword">int</span> status<span class="token punctuation">;</span>        pid_t wpid<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>wpid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>        <span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>wpid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>           <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" ----- child died pid = %d\n"</span><span class="token punctuation">,</span> wpid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"return value %d\n"</span><span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">WIFSIGNALED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"died by signal: %d\n"</span><span class="token punctuation">,</span> <span class="token function">WTERMSIG</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2在终端下查看某个正在运行的进程"><a href="#2-2在终端下查看某个正在运行的进程" class="headerlink" title="2.2在终端下查看某个正在运行的进程"></a>2.2在终端下查看某个正在运行的进程</h3><ul><li><p>查看进程</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ps</span> au<span class="token function">ps</span> aux<span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> myhello <span class="token punctuation">(</span>查看指定进程,经常使用<span class="token punctuation">)</span><span class="token function">ps</span> ajx<span class="token function">ps</span> ajx <span class="token operator">|</span> <span class="token function">grep</span> myhello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ps ajx 命令查看进程，输出PPID是父进程，PID是子进程，PGID是进程组，SID是会话ID</p></li><li><p>杀死进程<br>kill 向指定的进程发送信号</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">kill</span> -l （查看LINUX操作系统下的64个信号）<span class="token function">kill</span> -9  38078 <span class="token punctuation">(</span>无条件杀死一个进程（PID是38078）,9相当于LINUX操作系统下<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入kill -9  38078命令是无条件杀死一个进程。<br>38078是PID,9相当于LINUX操作系统下的第9个信号SIGKILL</p></li></ul><h2 id="3-exec函数族"><a href="#3-exec函数族" class="headerlink" title="3.exec函数族"></a>3.exec函数族</h2><h3 id="3-1-exec函数族概念"><a href="#3-1-exec函数族概念" class="headerlink" title="3.1 exec函数族概念"></a>3.1 exec函数族概念</h3><ul><li>让父子进程执行不相干的操作</li><li>能够替换进程地址空间中的源代码.txt数据段</li><li>当前程序中调用另外一个应用程序  <ul><li>实现换核不换壳的功能</li><li>执行一个另外的程序不需要创建额外的地址空间<br><img src="https://lsc123.github.io/my_picture/Linux_picture/exec.png" alt="exec"></li></ul></li></ul><h3 id="3-2-执行指定目录下的程序"><a href="#3-2-执行指定目录下的程序" class="headerlink" title="3.2 执行指定目录下的程序"></a>3.2 执行指定目录下的程序</h3><pre><code>int execl(const char *path, const char *arg, ...);§ path: 要执行的程序的绝对路径§ 变参arg: 要执行的程序的需要的参数§ 第一arg:占位§ 后边的arg: 命令的参数§ 参数写完之后: NULL</code></pre><p><strong><em>ececl函数一般执行自己写的程序</em></strong></p><pre><code>int execv(const char *path, char *const argv[]);        § 参数:        § path = /bin/ps        § char* args[] = {&quot;ps&quot;, &quot;aux&quot;, NULL};            □ execv(&quot;/bin/ps&quot;, args);</code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//　子进程执行程序</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//ls程序是使用的子进程的地址空间,占位里填写所要运行程序的名字</span>        <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span><span class="token string">"ls"</span><span class="token punctuation">,</span><span class="token string">"-l"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//execl("/home/kevin/hello", "xxxx",  NULL);</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" i = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3执行PATH环境变量能够搜索到的程序"><a href="#3-3执行PATH环境变量能够搜索到的程序" class="headerlink" title="3.3执行PATH环境变量能够搜索到的程序"></a>3.3执行PATH环境变量能够搜索到的程序</h3><p><strong><em>execlp函数执行系统自带的程序，/bin目录下的文件</em></strong><br><strong><em>execlp执行自定义的程序: file参数绝对路径</em></strong></p><pre><code>int execlp(const char *file, const char *arg, ...);        § file: 执行的命令的名字        § 第一arg:占位        § 后边的arg: 命令的参数        § 参数写完之后: NULLint execvp(const char *file, char *const argv[]);        § 参数:</code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//　子进程执行程序</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//占位里填写所要运行程序的名字</span>        <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"ps"</span><span class="token punctuation">,</span><span class="token string">"ps"</span><span class="token punctuation">,</span><span class="token string">"aux"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出eaect执行错误时，输出的错误信息，如果execl成功则不执行</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//退出当前进程</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" i = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4执行指定路径-指定环境变量下的程序-–-了解即可"><a href="#3-4执行指定路径-指定环境变量下的程序-–-了解即可" class="headerlink" title="3.4执行指定路径, 指定环境变量下的程序 – (了解即可)"></a>3.4执行指定路径, 指定环境变量下的程序 – (了解即可)</h3><pre><code>int execle(const char *path, const char *arg, ..., char *const envp[]);        § path: 执行的程序的绝对路径  /home/itcast/a.out        § arg: 执行的的程序的参数        § envp: 用户自己指定的搜索目录, 替代PATH            □ char* env[] = {&quot;/home/itcast&quot;, &quot;/bin&quot;, NULL};int execve(const char *path, char *const argv[], char *const envp[]);</code></pre><h2 id="4-进程回收"><a href="#4-进程回收" class="headerlink" title="4.进程回收"></a>4.进程回收</h2><h3 id="4-1-孤儿进程"><a href="#4-1-孤儿进程" class="headerlink" title="4.1 孤儿进程"></a>4.1 孤儿进程</h3><ul><li>父进程挂掉，子进程还存在，则此进程叫做孤儿进程</li><li>孤儿进程会被init进程（ubunt14.04版本以后为/sbin/upstart路径下,即ui进程）领养，init进程变为孤儿进程的父进程</li><li>为了释放子进程占用的系统资源<ul><li>子进程结束之后，能够释放用户区空间</li><li>释放不了pcb，必须由父进程释放，此时init进程起到了作用</li></ul></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//　子进程执行程序</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child process, pid = %d, ppid = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"==================parent\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent process, pid = %d, ppid = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">gcc guer.c./a.out （执行孤儿进程）<span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> 1492 <span class="token punctuation">(</span>1492为父进程pid<span class="token punctuation">)</span><span class="token function">kill</span> -9 1492<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输入kill -9 1492命令，则杀死父进程（init进程），系统重新回到桌面</p><h3 id="4-2-僵尸进程"><a href="#4-2-僵尸进程" class="headerlink" title="4.2 僵尸进程"></a>4.2 僵尸进程</h3><ul><li>父进程存在，子进程挂掉，父进程不去释放子进程的pcb，此时的子进程变为了僵尸进程</li><li>僵尸进程是一个已经挂掉的程序</li><li>杀死僵尸进程需要杀死它的父进程</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//　子进程执行程序</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child process, pid = %d, ppid = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span>（<span class="token number">1</span>）        <span class="token punctuation">{</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"==================parent\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent process, pid = %d, ppid = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">gcc jiangshi.c./a.out （执行僵尸进程）<span class="token function">ps</span> aux<span class="token function">kill</span> -9 40763（子进程pid）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>输入ps aux命令查看僵尸进程。Z+为僵尸英文首字母的意思，<defuct>为已经死亡的意思）</defuct></li><li>杀死僵尸进程，必须杀死其父进程，杀死父进程下后，僵尸进程被init进程收养，然后被init进程释放</li></ul><h3 id="4-3-进程回收"><a href="#4-3-进程回收" class="headerlink" title="4.3 进程回收"></a>4.3 进程回收</h3><pre><code>pid_t wait(int *status);    函数作用：        ① 阻塞并等待子进程退出         ② 回收子进程残留资源         ③ 获取子进程结束状态(退出原因)。    返回值：        成功：清理掉的子进程ID；        失败：-1 (没有子进程)    参数：子进程的退出状态 -- 传出参数        1.  WIFEXITED(status)：为非0   → 进程正常结束                WEXITSTATUS(status)：                如上宏为真，使用此宏 → 获取进程退出状态 (exit/return）的参数)        2.  WIFSIGNALED(status)：为非0 → 进程异常终止                WTERMSIG(status)：                如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。pid_t waitpid(pid_t pid, int *status, in options);函数作用：可以指定杀死一个子进程 ，其余功能与wait函数相同    参数：        ① pid：            pid == -1 回收所有的子进程                - 调用一次函数只能回收一个，必须循环回收                - while((wpid = waitpid(-1,&amp;status,xx)!= -1))            pid &gt; 0 等待其进程ID与pid相等的子进程。            pid == 0 回收当前进程组所有的子进程            pid &lt; -1 子进程的pid取反（加减号）        ② status: 子进程的退出状态，用法同wait函数        ③ options：             设置为WNOHANG，函数非阻塞，             设置为0，函数阻塞    返回值：        &gt;0：返回清理掉的子进程ID；        -1：回收失败，无子进程        =0：参3为WNOHANG，且子进程正在运行。</code></pre><h2 id="5-进程间通信相关概念"><a href="#5-进程间通信相关概念" class="headerlink" title="5.进程间通信相关概念"></a>5.进程间通信相关概念</h2><pre><code>1. 什么是IPC    a. 进程间通信         InterProcess Communication2. 进程间通信常用的4种方式    a. 管道 - 简单    b. 信号 - 系统开销    c. 共享映射区 - （有/无血缘关系的进程间通信都可以）    d. 本地套接字 - 稳定</code></pre><h3 id="管道（匿名）"><a href="#管道（匿名）" class="headerlink" title="管道（匿名）"></a>管道（匿名）</h3><pre><code>1. 管道的概念    ○ 本质:          § 内核缓冲区         § 伪文件 - 不占用磁盘空间    ○ 特点:        § 两部分：            □ 读端，写端，对应两个文件描述符            □ 数据写端流入， 读端流出        § 操作管道的进程被销毁之后，管道自动被释放了        § 管道默认是阻塞的。            □ 读写2. 管道的原理    ○ 内部实现方式：队列        § 环形队列        § 特点：先进先出    ○ 缓冲区大小：        § 默认4k        § 大小会根据实际情况做适当调整3. 管道的局限性    ○ 队列：        § 数据只能读取一次，不能重复读取    ○ 半双工：        § 单工：遥控器        § 半双工：对讲机            □ 数据传输的方向是单向的        § 双工：电话    ○ 匿名管道：        § 适用于有血缘关系的进程4. 创建匿名管道    ○ int pipe(int fd[2]);        § fd- 传出参数        § fd[0] - 读端        § fd[1] - 写端5. 父子进程使用管道通信    ○ 思考:         § 单个进程能否使用管道完成读写操作?            □ 可以        § 父子进程间通信是否需要sleep函数?            □ 父 写 -- 写的慢            □ 子 读 -- 读的快    ○ 注意事项：        父进程读            -- 关闭写端        子进程写            -- 关闭读端    ○ 练习        § 父子进程间通信, 实现ps aux | grep bash            □ 数据重定向: dup2            □ execlp        § 兄弟进程间通信, 实现ps aux | grep bash            □ 父亲 - 资源回收1. 管道的读写行为    ○ 读操作        § 有数据            □ read（fd） - 正常读，返回读出的字节数        § 无数据            □ 写端全部关闭                ® read解除阻塞，返回0                ® 相当于读文件读到了尾部            □ 没有全部关闭                ® read阻塞    ○ 写操作        § 读端全部关闭            □ 管道破裂，进程被终止                ® 内核给当前进程发信号SIGPIPE        § 读端没全部关闭            □ 缓冲区写满了                ® write 阻塞            □ 缓冲区没有满                ® write继续写    ○ 如何设置非阻塞?        § 默认读写两端都阻塞        § 设置读端为非阻塞pipe（fd）            □ fcntl - 变参函数                ® 复制文件文件描述符 - dup                ® 修改文件属性 - open的时候对应flag属性            □ 设置方法：            获取原来的flags            int flags = fcntl(fd[0], F_GETFL);            // 设置新的flags            flag |= O_NONBLOCK;            // flags = flags | O_NONBLOCK;            fcntl(fd[0], F_SETFL, flags);2. 查看管道缓冲区大小    ○ 命令        § ulimit -a    ○ 函数        § fpathconf</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-进程相关概念&quot;&gt;&lt;a href=&quot;#1-进程相关概念&quot; class=&quot;headerlink&quot; title=&quot;1. 进程相关概念&quot;&gt;&lt;/a&gt;1. 进程相关概念&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://lsc123.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://lsc123.github.io/2019/03/22/hello-world/"/>
    <id>https://lsc123.github.io/2019/03/22/hello-world/</id>
    <published>2019-03-22T06:07:51.315Z</published>
    <updated>2019-03-26T13:57:56.927Z</updated>
    
    <content type="html"><![CDATA[<p>１.由于markdown语法主要考虑的是英文，所以对于中文的首行缩进并不太友好</p><ul><li>把输入法由半角改为全角。 两次空格之后就能够有两个汉字的缩进。</li></ul><a id="more"></a><p>２.文章置顶<br>&amp;ensp打开文章添加top字段,设置数值，数值越大文章越靠前</p><p>3.首行缩进<br>//相当于1个中文，2字节</p><p>4.换行<br>双空格加回车可实现 hexo文章中的换行功能（在上文代码块中亦适用）</p><p>5.文章折叠<br>在要显示的文字末尾添加如下代码实现文章在主页的折叠显示。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- <span class="token function">more</span> --<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　Linux系统将每个对象当作文件处理，这包括输入和输出进程。Linux用文件描述符(file descriptor)来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文件描述符(0、1和2)，这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。下面南昌网络公司-百恒网络就来为大家介绍一下这些标准文件描述符，供大家参考!</p><p>##一、STDIN</p><p>　　STDIN文件描述符代表shell的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN 文件描述符对应的键盘获得输入，在用户输入时处理每个字符。</p><p>　　在使用输入重定向符号(&lt;)时，Linux会用重定向指定的文件来替换标准输入文件描述符。 它会读取文件并提取数据，就如同它是键盘上键入的。</p><p>　　许多bash命令能接受STDIN的输入，尤其是没有在命令行上指定文件的话。下面是个用cat 命令处理STDIN输入的数据的例子。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span>this is a <span class="token function">test</span>this is a <span class="token function">test</span>this is a second test.this is a second test.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　当在命令行上只输入cat命令时，它会从STDIN接受输入。输入一行，cat命令就会显示出 一行。但你也可以通过STDIN重定向符号强制cat命令接受来自另一个非STDIN文件的输入。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">&lt;</span> testfileThis is the first line.This is the second line.This is the third line.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　现在cat命令会用testfile文件中的行作为输入。你可以使用这种技术将数据输入到任何能从 STDIN接受数据的shell命令中。</p><p>##二、STDOUT</p><p>　　STDOUT文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。shell 的所有输出(包括shell中运行的程序和脚本)会被定向到标准输出中，也就是显示器。</p><p>　　默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。同时，你也可以用输出重定向来改变。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l <span class="token operator">></span> test2$ <span class="token function">cat</span> test2total 20-rw-rw-r-- 1 rich rich 53 2014-10-16 11:30 <span class="token function">test</span>-rw-rw-r-- 1 rich rich 0 2014-10-16 11:32 test2-rw-rw-r-- 1 rich rich 73 2014-10-16 11:23 testfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　通过输出重定向符号，通常会显示到显示器的所有输出会被shell重定向到指定的重定向文件。你也可以将数据追加到某个文件。这可以用&gt;&gt;符号来完成。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">who</span> <span class="token operator">>></span> test2$ <span class="token function">cat</span> test2total 20-rw-rw-r-- 1 rich rich 53 2014-10-16 11:30 <span class="token function">test</span>-rw-rw-r-- 1 rich rich 0 2014-10-16 11:32 test2-rw-rw-r-- 1 rich rich 73 2014-10-16 11:23 testfilerich pts/0 2014-10-17 15:34 <span class="token punctuation">(</span>192.168.1.2<span class="token punctuation">)</span>$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　who命令生成的输出会被追加到test2文件中已有数据的后面。 但是，如果你对脚本使用了标准输出重定向，你会遇到一个问题。下面的例子说明了可能会出现什么情况。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -al badfile <span class="token operator">></span> test3ls: cannot access badfile: No such <span class="token function">file</span> or directory$ <span class="token function">cat</span> test3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重 定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。</p><p>　　shell对于错误消息的处理是跟普通输出分开的。如果你创建了在后台模式下运行的shell脚本，通常你必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。你需要换种方法来处理。</p><h2 id="三、STDERR"><a href="#三、STDERR" class="headerlink" title="三、STDERR"></a>三、STDERR</h2><p>　　shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方(尽管分配给它们的文件描述符值不同)。也就是说，默认情况下，错误消息也会输出到显示器输出中。<br>　　但从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，你常常会想改变这种行为，尤其是当你希望将错误消息保存到日志文件中的时候。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;１.由于markdown语法主要考虑的是英文，所以对于中文的首行缩进并不太友好&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把输入法由半角改为全角。 两次空格之后就能够有两个汉字的缩进。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>嵌入式Linux开发笔记 &lt;一&gt;  Linux环境搭建</title>
    <link href="https://lsc123.github.io/2019/03/19/post-title/"/>
    <id>https://lsc123.github.io/2019/03/19/post-title/</id>
    <published>2019-03-18T16:09:20.000Z</published>
    <updated>2019-03-24T15:28:58.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lt-一-gt-Linux环境搭建"><a href="#lt-一-gt-Linux环境搭建" class="headerlink" title="&lt;一&gt;  Linux环境搭建"></a><strong>&lt;一&gt;  Linux环境搭建</strong></h1><a id="more"></a><h2 id="1-安装VMware-Workstation虚拟机"><a href="#1-安装VMware-Workstation虚拟机" class="headerlink" title="1.安装VMware Workstation虚拟机"></a>1.安装VMware Workstation虚拟机</h2><p>挂载：<br>    它指将一个设备（通常是存储设备）挂接到一个已存在的目录上（这个目录可以不为空，但挂载后这个目录下以前的内容将不可用）我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。</p><h2 id="2-安装ubuntu及相关服务"><a href="#2-安装ubuntu及相关服务" class="headerlink" title="2.安装ubuntu及相关服务"></a>2.安装ubuntu及相关服务</h2><h3 id="2-1-安装编辑器VIM"><a href="#2-1-安装编辑器VIM" class="headerlink" title="2.1 安装编辑器VIM"></a>2.1 安装编辑器VIM</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> vim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-SSHD服务"><a href="#2-2-SSHD服务" class="headerlink" title="2.2 SSHD服务"></a>2.2 SSHD服务</h3><p>  ssh：Secure shell<br>  分为客户端和服务端<br><strong>(1)安装SecureCRT客户端</strong><br>远程登录服务器<br><strong>(2)zmodem协议</strong><br>rz 命令(上传)<br>以zmodem协议receive<br>sz 命令（下载）<br>以zmodem协议send</p><p>rz命令以后出现选择文件框选择完以后<br>输入rz命令可以查看文件<br>输入ls命令可以查看根目录<br>输入cat+文件名命令可以查看文件内容</p><p>上传下载例子：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">vi</span> mytest.txt（创建文件）//输入编辑内容:wq（保存退出）ls（查看目录）sz mytest.txt <span class="token punctuation">(</span>下载文件<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3samba服务器"><a href="#2-3samba服务器" class="headerlink" title="2.3samba服务器"></a>2.3samba服务器</h3><p>简介：<br>SMB 协议：Server Message Block（服务消息块）<br>Linux模拟windows（SAMBA服务），与windows通讯</p><h4 id="1-安装samba服务器"><a href="#1-安装samba服务器" class="headerlink" title="1.安装samba服务器"></a>1.安装samba服务器</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> samba<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-samba服务器的配置"><a href="#2-samba服务器的配置" class="headerlink" title="2.samba服务器的配置"></a>2.samba服务器的配置</h4><p>（1）/etc/samba/smb.conf<br>    samba的用户权限：<br>    smbpasswd   （命令）<br>    Linux 登录用户<br>    Samba登录用户（用户名共享，密码不共享）<br>    配置需要共享哪个目录，以及这个目录的访问权限</p><p>（2）配置samba访问权限及samba登录密码：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /etc/samba  （进入Samba文件夹）<span class="token function">ls</span><span class="token function">cp</span> smb.conf bak_smb.conf（复制文件）<span class="token function">ls</span><span class="token function">sudo</span> <span class="token function">vi</span>  smb.conf（查看文件）         按i进入编辑模式          <span class="token punctuation">[</span>lsc_share<span class="token punctuation">]</span>                 comment<span class="token operator">=</span>My share （标题）                  path<span class="token operator">=</span>/home/lsc/lab （共享目录）                  writable<span class="token operator">=</span>yes             （是否可写）                  browseable<span class="token operator">=</span>yes       （是否可以浏览）                  public<span class="token operator">=</span>yes                  guest ok<span class="token operator">=</span>yes            （客户是否连接）         按ESC退出编辑模式         :wq  （保存退出命令）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）/——-以下命令在  /etc/samba$  下进行—————-/ </p><pre class="line-numbers language-bash"><code class="language-bash">    -a（只能增加一个现有用户）    <span class="token function">sudo</span> smbpasswd -a  lsc    New SMB password: 123    Retype new SMB password: 123    <span class="token function">sudo</span> /etc/init.d/smbd restart（重启）    <span class="token function">sudo</span> /etc/init.d/nmbd restart（重启）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-windows客户端的访问方式"><a href="#3-windows客户端的访问方式" class="headerlink" title="3.windows客户端的访问方式"></a>3.windows客户端的访问方式</h2><h3 id="3-1在windows下创建虚拟共享目录："><a href="#3-1在windows下创建虚拟共享目录：" class="headerlink" title="3.1在windows下创建虚拟共享目录："></a>3.1在windows下创建虚拟共享目录：</h3><p>1.在Linux终端输入</p><pre class="line-numbers language-bash"><code class="language-bash"> ifconfig（查看IP地址）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.windows下输入运行<br>3.在 运行中输入  \IP地址<br>（初始状态下弹出输入用户名和密码。为上面所设置的内容）<br>4.查看共享目录<br>发现没有（在Linux下输入以下命令）</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span>  /home/lsc/<span class="token function">ls</span><span class="token function">mkdir</span> lab （创建目录）<span class="token function">cd</span> lab/<span class="token function">ls</span><span class="token function">vi</span>  123.txt//编辑内容（内容随意，用于测试）：wq（保存退出）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.再去看共享目录，发现有123.txt文件</p><h3 id="3-2映射网络驱动器（盘符）："><a href="#3-2映射网络驱动器（盘符）：" class="headerlink" title="3.2映射网络驱动器（盘符）："></a>3.2映射网络驱动器（盘符）：</h3><p> （相当于将Linux的共享盘当做U盘放在Windows当中的映射服务）</p><ol><li>选择盘符（默认）</li><li><em>\192.168.220.129\lsc_share</em>(lsc_share为前面创建的分享目录)<br>(地址通过ifcofig命令查看，共享文件为所创建的方括号内的名字)</li><li>建立一个文件（.txt），用于测试</li><li>在linux下输入<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> ./lab<span class="token function">ls</span><span class="token function">cat</span> abc.txt <span class="token punctuation">(</span>查看文件<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="4-vmtools的安装"><a href="#4-vmtools的安装" class="headerlink" title="4.vmtools的安装"></a>4.vmtools的安装</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">su</span>     （进入root用户）<span class="token function">mkdir</span> /mnt/cdrom    <span class="token punctuation">(</span>在mnt目录下创建cdrom文件夹，用于下一步使用<span class="token punctuation">)</span><span class="token function">mount</span>  /dev/cdrom  /mnt/cdrom    （将光驱上的文件挂载在我们新建的文件夹里面）<span class="token function">cd</span>  /mnt/cdrom（将操作目录切换到mnt目录下的cdrom文件夹里面）<span class="token function">ls</span> <span class="token punctuation">(</span>查看后我们可以看到，VMware Tools工具被成功的放在了新建的文件夹下<span class="token punctuation">)</span><span class="token function">cp</span> VMwareTools-10.1.15-6627299.tar.gz /tmp（将VMwareTools压缩包复制到tmp目录下）<span class="token function">cd</span> /tmp（将操作目录切换到tmp目录下）<span class="token function">tar</span> -zxvf VMwareTools-10.1.15-6627299.tar.gz（将VMwareTools压缩包解压）<span class="token function">sudo</span> vmware-tools-distrib/vmware-install.pl      进行VMwareTools工具的安装。（注意安装的时候，不管出现什么，全部按enter键就行了）    完成安装后，我们重新启动我们的linux虚拟机，我们就会看到我们的共享文件夹了<span class="token function">cd</span> /mnt<span class="token function">ls</span><span class="token function">cd</span> hgfs/14. 点击设置里的选项中的共享文件夹15.选择总是启用16. 从Windows里选择一个文件夹，此文件夹相当于一个U盘一样存储Linux所建立的文件实现交互<span class="token function">ls</span> <span class="token punctuation">(</span>查看我们所建立的文件夹<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> tar命令扩展：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">tar</span> -zxvf VMwareTools-10.1.15-6627299.tar.gz -C /tmp/（将文件解压到tmp目录下）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5-SourceInsight安装"><a href="#5-SourceInsight安装" class="headerlink" title="5.SourceInsight安装"></a>5.SourceInsight安装</h2><p>代码编译器利器</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lt-一-gt-Linux环境搭建&quot;&gt;&lt;a href=&quot;#lt-一-gt-Linux环境搭建&quot; class=&quot;headerlink&quot; title=&quot;&amp;lt;一&amp;gt;  Linux环境搭建&quot;&gt;&lt;/a&gt;&lt;strong&gt;&amp;lt;一&amp;gt;  Linux环境搭建&lt;/strong&gt;&lt;/h1&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://lsc123.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
