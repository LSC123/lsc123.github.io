<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[嵌入式Linux开发笔记 Linux进程]]></title>
    <url>%2F2019%2F03%2F24%2FLinux-3%2F</url>
    <content type="text"><![CDATA[1. 进程相关概念 1.1程序和进程 程序： 二进制文件，占用的磁盘空间 进程： 启动的程序 所有的数据都在内存中 需要占用更多的系统资源（cpu,物理内存），分成若干个时间碎片，给进程处理 1.2并行和并发 并发：并发并不是一个时间点，而是一个时间段内的概念 并行：并行是指两个或者多个事件在同一时刻发生 1.3进程控制块(PCB) 每一个进程在内核里都有一个进程控制块来维护进程相关的信息。Linux内核的进程控制块是task_struct结构体，在/usr/src/linux-header-3.16/include/linux/sched.h文件里可以查看struct task_struct结构体的定义，其内部成员有很多，重点掌握以下内容 进程ID： 系统中每个进程都有唯一的ID，在C语言中用pid_t类型表示，其实就是一个非负整数。pid_t是用typedef对某个数据类型做了重定义，后面的_t是就是typedef的意思 进程的状态： 有就绪，允许，运行，挂起，停止等状态 进程切换时需要保存和恢复的一些CPU寄存器 描述虚拟地址空间的信息 在Linux下，每启动一个虚拟进程就对应一个虚拟地址空间，包含应用程序的所有信息，但是里面数据的实际计算是在物理内存里（cpu里的MMU会做一个虚拟内存到物理内存之间的映射） 描述控制终端的信息 ./a.out执行起来就变成一个进程，进程在运行时，依赖于终端，因为需要把数据输出到对应的终端上，所以进程会保存一些控制终端的信息 当前工作目录（Current Working Directory） 当前进程是在哪个工作目录下工作的 pwd 在Linux下执行pwd,输出当前工作目录，是因为当前工作目录保存在地址空间中 umask掩码 在每一个进程下都有umask掩码 umask umask 222 umask 使用umask命令查看掩码，使用umask 222 改变进程掩码，在使用umask查看掩码，发现掩码改变为我们过设定的值。当再开启一个进程时，掩码为此进程下的掩码，与刚开始的进程下的修改的掩码不同，每一个进程之间是互不影响的 文件描述符表，包含很多指向file结构体的指针 文件描述符表在pcb里，其实可以看成一个大小为1024数组，对于任何一个进程来说，默认能打开的最多文件个数为1024个，把内核改一下，重新编译一下内核，就可以改变能打开的最多文件个数，不过不建议轻易改动内核，除非特殊需要 和信号相关的信息 Linux下独有的 用户ID和组ID stat test.c 输入stat加文件名，查看文件状态uid和Gid后的就是用户ID和组ID 会话（Session）和进程组 多个进程放在一起就是一个进程组，多个进程组组成的就是会话 进程可以使用的资源上限（Resource Limit） ulimit -a 输入 ulimit -a命令，可以看到进程里的资源，例如默认能打开的文件个数，管道里的缓存区，栈的默认缓存区大小，都在资源上限里看到，这些数据都是存在进程控制块里， 1.4进程的五种状态 就绪态 在终端下执行./a.out后，进程有了，它所对应的地址空间也有了，所处的状态为就绪态，有执行资格，没有执行权，多个进程分用cpu的时间碎片，在没有分到时间碎片时，处于就绪态 运行态 当抢到时间碎片后，处于运行态，所有的运行态都是从就绪态而来 挂起态 没有执行资格，没有执行权（例如运行sleep()函数后） 2. 进程控制进程控制是讲如何创建子进程 2.1fork函数 fork函数创建子进程，子进程相当于父进程的拷贝，用户区数据一样，进程ID不同后续对父进程或子进程用户区数据做操作，互不影响，相互独立 父进程与子进程的数据在内存区读时共享，写时复制（当就修改的情况下），并且父子进程之间不能够使用全局变量进行通信，因为两个进程之间的内存不能共享 fork函数有两个返回值 父进程返回子进程的PID 子进程返回0 getpid函数 得到当前进程的PID getppid函数 得到当前进程的父进程的PID 2.1.1父子进程运行先后顺序不一定通过让父进程sleep(1)来让子进程先运行 #include &lt;unistd.h> #include &lt;stdlib.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;string.h> int main(int argc, const char* argv[]) { pid_t pid = fork(); for(int i=0; i&lt;4; ++i) { printf(" i = %d\n", i); } // 父进程 if(pid > 0) { printf("parent process, pid = %d, ppid = %d\n", getpid(), getppid()); //sleep(1); } // 子进程 else if(pid == 0) { printf("child process, pid = %d, ppid = %d\n", getpid(), getppid()); } for(int i=0; i&lt;4; ++i) { printf(" i = %d\n", i); } return 0; } sleep(1)的作用是让父进程停止一秒，让子进程运行，防止父进程先运行结束，在终端打印时，父进程先运行完后，终端判断从后台运行到前台，此时子进程还未运行结束会出现下面这种输出情况 执行./a.out i=0 i=1 i=2 i=3 parent process, ppid = 37157 lsc@lsc123:~/test $ child process, pid =37258 , ppid = 37157 i=0 i=1 i=2 i=3 正确输出为 执行./a.out i=0 i=1 i=2 i=3 parent process, ppid = 37157 child process, pid =37258 , ppid = 37157 i=0 i=1 i=2 i=3 2.1.2验证父子进程间是否共享全局变量#include &lt;stdio.h> #include &lt;unistd.h> #include &lt;stdlib.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;string.h> int counter = 100; int main(int argc, const char* argv[]) { pid_t pid; int i=0; for(i=0; i&lt;3; i++) { pid = fork(); if(pid == 0) { break; } } // 父进程 if(i == 3) { counter += 100; printf("parent process, pid = %d, ppid = %d, %d\n", getpid(), getppid(), counter); // sleep(1); } // 子进程 else if(i == 0) { // 1th counter += 200; printf("child process, pid = %d, ppid = %d, %d\n", getpid(), getppid(), counter); } else if(i == 1) { // 2th counter += 300; printf("child process, pid = %d, ppid = %d, %d\n", getpid(), getppid(), counter); } else if(i == 2) { // 3th counter += 400; printf("child process, pid = %d, ppid = %d, %d\n", getpid(), getppid(), counter); } return 0; } 2.1.3 例程-验证父子进程间使用文件进行通信 父进程内核区有一个pcb,pcb中有一个文件描述符表，文件描述符表中含有1024个文件描述符，前三个被占用（0-2 stdin,stdout,stderr），在父进程中的3号文件描述符指向创建的temp文件，执行一个fork操作，创建一个子进程，除了进程ID不同，其余与父进程相同，子进程的文件描述符表同样与父进程相同，因此子进程的3号文件描述符也指向了temp文件 1.打开一个temp文件，如果没有就创建一个2.创建一个子进程3.向父进程中写入一段数据，并关闭父进程4.子进程睡1s保证父进程已经完成了文件的写操作5.temp文件只要吧被父子进程中的一个文件描述符占用，temp里的文件指针就不会移动到头部，因此需要使用lseek()函数将文件指针移动到头部,保证数据能够读出来6.把文件里数据读到buf[]组中，输出出来 如果能将子进程能读出父进程写入的数据并打印出来，则说明父子进程间可以使用文件进行通信 #include &lt;stdio.h> #include &lt;unistd.h> #include &lt;stdlib.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;string.h> #include &lt;fcntl.h> // 操作终端文件 /dev/tty默认阻塞 int main(int argc, const char* argv[]) { int fd = open("temp", O_CREAT | O_RDWR, 0664); if(fd == -1) { perror("open error"); exit(1); } pid_t pid = fork(); if(pid == -1) { perror("fork error"); exit(1); } if(pid > 0) { char* p = "近期，微软向Linux开发人员伸出了橄榄枝，希望Linux开发人员能够转移到Windows 10平台上进行开发。"; write(fd, p, strlen(p)+1); close(fd); } else if(pid == 0) { // 睡1s保证父进程已经完成了文件的写操作 sleep(1); char buf[1024]; lseek(fd, 0, SEEK_SET); int len = read(fd, buf, sizeof(buf)); printf("%s\n", buf); close(fd); } return 0; } gcc process_file.c ./a.out 2.1.4 例程-父进程fork三个子进程父进程fork三个子进程 其中一个调用ps命令; 一个调用自定义应用程序; 一个调用会出现段错误的程序。 父进程回收三个子进程(waitpid)，并且打印三个子进程的退出状态。 当发生了段错误以后，系统会执行11号信号SIGSEGV（输入kill -l 命令可以查看）,11号信号就是段错误的意思，假设写的应用程序满足了段错误的条件，内核就会给应用程序发一个11号信号，当应用程序收到11号程序，程序就会结束 === 段错误 === 1. 访问了非法内存 2. 访问了不可写的区域进行写操作 3. 栈空间溢出 #include &lt;stdio.h> #include &lt;sys/wait.h> #include &lt;unistd.h> #include &lt;stdlib.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;string.h> int main(int argc, const char* argv[]) { int num = 3; int i = 0; pid_t pid; for(i=0; i&lt;num; ++i) { pid = fork(); if(pid == 0) { break; } } if(i == 0) { execlp("ps", "ps", "aux", NULL); perror("execlp ps"); exit(1); } else if(i == 1) { execl("/home/kevin/test/app", "app", NULL); perror("execl app"); exit(1); } else if(i == 2) { execl("./error", "error", NULL);//执行段错误应用程序 perror("execl error"); exit(1); } else if(i == num) { // 回收 int status; pid_t wpid; while( (wpid = (waitpid(-1, &amp;status, WNOHANG)) != -1) ) { if(wpid == 0) { continue; } printf(" ----- child died pid = %d\n", wpid); if(WIFEXITED(status)) { printf("return value %d\n", WEXITSTATUS(status)); } else if(WIFSIGNALED(status)) { printf("died by signal: %d\n", WTERMSIG(status)); } } } return 0; } 2.2在终端下查看某个正在运行的进程 查看进程 ps au ps aux ps aux | grep myhello (查看指定进程,经常使用) ps ajx ps ajx | grep myhello ps ajx 命令查看进程，输出PPID是父进程，PID是子进程，PGID是进程组，SID是会话ID 杀死进程kill 向指定的进程发送信号 kill -l （查看LINUX操作系统下的64个信号） kill -9 38078 (无条件杀死一个进程（PID是38078）,9相当于LINUX操作系统下) 输入kill -9 38078命令是无条件杀死一个进程。38078是PID,9相当于LINUX操作系统下的第9个信号SIGKILL 3.exec函数族3.1 exec函数族概念 让父子进程执行不相干的操作 能够替换进程地址空间中的源代码.txt数据段 当前程序中调用另外一个应用程序 实现换核不换壳的功能 执行一个另外的程序不需要创建额外的地址空间 3.2 执行指定目录下的程序int execl(const char *path, const char *arg, ...); § path: 要执行的程序的绝对路径 § 变参arg: 要执行的程序的需要的参数 § 第一arg:占位 § 后边的arg: 命令的参数 § 参数写完之后: NULL ececl函数一般执行自己写的程序 int execv(const char *path, char *const argv[]); § 参数: § path = /bin/ps § char* args[] = {&quot;ps&quot;, &quot;aux&quot;, NULL}; □ execv(&quot;/bin/ps&quot;, args); #include &lt;stdio.h> #include &lt;unistd.h> #include &lt;stdlib.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;string.h> int main(int argc, const char* argv[]) { printf("hello, world\n"); pid_t pid = fork(); if(pid == -1) { perror("fork error"); exit(1); } // 子进程执行程序 if(pid == 0) { //ls程序是使用的子进程的地址空间,占位里填写所要运行程序的名字 execl("/bin/ls","ls","-l",NULL); //execl("/home/kevin/hello", "xxxx", NULL); perror("execl"); exit(1); } for(int i=0; i&lt;3; ++i) { printf(" i = %d\n", i); } return 0; } 3.3执行PATH环境变量能够搜索到的程序execlp函数执行系统自带的程序，/bin目录下的文件execlp执行自定义的程序: file参数绝对路径 int execlp(const char *file, const char *arg, ...); § file: 执行的命令的名字 § 第一arg:占位 § 后边的arg: 命令的参数 § 参数写完之后: NULL int execvp(const char *file, char *const argv[]); § 参数: #include &lt;stdio.h> #include &lt;unistd.h> #include &lt;stdlib.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;string.h> int main(int argc, const char* argv[]) { printf("hello, world\n"); pid_t pid = fork(); if(pid == -1) { perror("fork error"); exit(1); } // 子进程执行程序 if(pid == 0) { //占位里填写所要运行程序的名字 execl("ps","ps","aux",NULL); perror("execl");//输出eaect执行错误时，输出的错误信息，如果execl成功则不执行 exit(1);//退出当前进程 } for(int i=0; i&lt;3; ++i) { printf(" i = %d\n", i); } return 0; } 3.4执行指定路径, 指定环境变量下的程序 – (了解即可)int execle(const char *path, const char *arg, ..., char *const envp[]); § path: 执行的程序的绝对路径 /home/itcast/a.out § arg: 执行的的程序的参数 § envp: 用户自己指定的搜索目录, 替代PATH □ char* env[] = {&quot;/home/itcast&quot;, &quot;/bin&quot;, NULL}; int execve(const char *path, char *const argv[], char *const envp[]); 4.进程回收4.1 孤儿进程 父进程挂掉，子进程还存在，则此进程叫做孤儿进程 孤儿进程会被init进程（ubunt14.04版本以后为/sbin/upstart路径下,即ui进程）领养，init进程变为孤儿进程的父进程 为了释放子进程占用的系统资源 子进程结束之后，能够释放用户区空间 释放不了pcb，必须由父进程释放，此时init进程起到了作用 #include &lt;stdio.h> #include &lt;unistd.h> #include &lt;stdlib.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;string.h> int main(int argc, const char* argv[]) { pid_t pid = fork(); if(pid == -1) { perror("fork error"); exit(1); } // 子进程执行程序 if(pid == 0) { sleep(1); printf("child process, pid = %d, ppid = %d\n", getpid(), getppid()); } else if(pid>0) { printf("==================parent\n"); printf("parent process, pid = %d, ppid = %d\n", getpid(), getppid()); } return 0; } gcc guer.c ./a.out （执行孤儿进程） ps aux | grep 1492 (1492为父进程pid) kill -9 1492 输入kill -9 1492命令，则杀死父进程（init进程），系统重新回到桌面 4.2 僵尸进程 父进程存在，子进程挂掉，父进程不去释放子进程的pcb，此时的子进程变为了僵尸进程 僵尸进程是一个已经挂掉的程序 杀死僵尸进程需要杀死它的父进程 #include &lt;stdio.h> #include &lt;unistd.h> #include &lt;stdlib.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;string.h> int main(int argc, const char* argv[]) { pid_t pid = fork(); if(pid == -1) { perror("fork error"); exit(1); } // 子进程执行程序 if(pid == 0) { printf("child process, pid = %d, ppid = %d\n", getpid(), getppid()); } else if(pid>0) { while（1） { sleep(1); printf("==================parent\n"); printf("parent process, pid = %d, ppid = %d\n", getpid(), getppid()); } } return 0; } gcc jiangshi.c ./a.out （执行僵尸进程） ps aux kill -9 40763（子进程pid） 输入ps aux命令查看僵尸进程。Z+为僵尸英文首字母的意思，为已经死亡的意思） 杀死僵尸进程，必须杀死其父进程，杀死父进程下后，僵尸进程被init进程收养，然后被init进程释放 4.3 进程回收pid_t wait(int *status); 函数作用： ① 阻塞并等待子进程退出 ② 回收子进程残留资源 ③ 获取子进程结束状态(退出原因)。 返回值： 成功：清理掉的子进程ID； 失败：-1 (没有子进程) 参数：子进程的退出状态 -- 传出参数 1. WIFEXITED(status)：为非0 → 进程正常结束 WEXITSTATUS(status)： 如上宏为真，使用此宏 → 获取进程退出状态 (exit/return）的参数) 2. WIFSIGNALED(status)：为非0 → 进程异常终止 WTERMSIG(status)： 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。 pid_t waitpid(pid_t pid, int *status, in options); 函数作用：可以指定杀死一个子进程 ，其余功能与wait函数相同 参数： ① pid： pid == -1 回收所有的子进程 - 调用一次函数只能回收一个，必须循环回收 - while((wpid = waitpid(-1,&amp;status,xx)!= -1)) pid &gt; 0 等待其进程ID与pid相等的子进程。 pid == 0 回收当前进程组所有的子进程 pid &lt; -1 子进程的pid取反（加减号） ② status: 子进程的退出状态，用法同wait函数 ③ options： 设置为WNOHANG，函数非阻塞， 设置为0，函数阻塞 返回值： &gt;0：返回清理掉的子进程ID； -1：回收失败，无子进程 =0：参3为WNOHANG，且子进程正在运行。 5.进程间通信相关概念1. 什么是IPC a. 进程间通信 InterProcess Communication 2. 进程间通信常用的4种方式 a. 管道 - 简单 b. 信号 - 系统开销 c. 共享映射区 - （有/无血缘关系的进程间通信都可以） d. 本地套接字 - 稳定 管道（匿名）1. 管道的概念 ○ 本质: § 内核缓冲区 § 伪文件 - 不占用磁盘空间 ○ 特点: § 两部分： □ 读端，写端，对应两个文件描述符 □ 数据写端流入， 读端流出 § 操作管道的进程被销毁之后，管道自动被释放了 § 管道默认是阻塞的。 □ 读写 2. 管道的原理 ○ 内部实现方式：队列 § 环形队列 § 特点：先进先出 ○ 缓冲区大小： § 默认4k § 大小会根据实际情况做适当调整 3. 管道的局限性 ○ 队列： § 数据只能读取一次，不能重复读取 ○ 半双工： § 单工：遥控器 § 半双工：对讲机 □ 数据传输的方向是单向的 § 双工：电话 ○ 匿名管道： § 适用于有血缘关系的进程 4. 创建匿名管道 ○ int pipe(int fd[2]); § fd- 传出参数 § fd[0] - 读端 § fd[1] - 写端 5. 父子进程使用管道通信 ○ 思考: § 单个进程能否使用管道完成读写操作? □ 可以 § 父子进程间通信是否需要sleep函数? □ 父 写 -- 写的慢 □ 子 读 -- 读的快 ○ 注意事项： 父进程读 -- 关闭写端 子进程写 -- 关闭读端 ○ 练习 § 父子进程间通信, 实现ps aux | grep bash □ 数据重定向: dup2 □ execlp § 兄弟进程间通信, 实现ps aux | grep bash □ 父亲 - 资源回收 1. 管道的读写行为 ○ 读操作 § 有数据 □ read（fd） - 正常读，返回读出的字节数 § 无数据 □ 写端全部关闭 ® read解除阻塞，返回0 ® 相当于读文件读到了尾部 □ 没有全部关闭 ® read阻塞 ○ 写操作 § 读端全部关闭 □ 管道破裂，进程被终止 ® 内核给当前进程发信号SIGPIPE § 读端没全部关闭 □ 缓冲区写满了 ® write 阻塞 □ 缓冲区没有满 ® write继续写 ○ 如何设置非阻塞? § 默认读写两端都阻塞 § 设置读端为非阻塞pipe（fd） □ fcntl - 变参函数 ® 复制文件文件描述符 - dup ® 修改文件属性 - open的时候对应flag属性 □ 设置方法： 获取原来的flags int flags = fcntl(fd[0], F_GETFL); // 设置新的flags flag |= O_NONBLOCK; // flags = flags | O_NONBLOCK; fcntl(fd[0], F_SETFL, flags); 2. 查看管道缓冲区大小 ○ 命令 § ulimit -a ○ 函数 § fpathconf]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[１.由于markdown语法主要考虑的是英文，所以对于中文的首行缩进并不太友好 把输入法由半角改为全角。 两次空格之后就能够有两个汉字的缩进。 ２.文章置顶&amp;ensp打开文章添加top字段,设置数值，数值越大文章越靠前 3.首行缩进//相当于1个中文，2字节 4.换行双空格加回车可实现 hexo文章中的换行功能（在上文代码块中亦适用） 5.文章折叠在要显示的文字末尾添加如下代码实现文章在主页的折叠显示。 &lt;!-- more --> Linux系统将每个对象当作文件处理，这包括输入和输出进程。Linux用文件描述符(file descriptor)来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文件描述符(0、1和2)，这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。下面南昌网络公司-百恒网络就来为大家介绍一下这些标准文件描述符，供大家参考! ##一、STDIN STDIN文件描述符代表shell的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN 文件描述符对应的键盘获得输入，在用户输入时处理每个字符。 在使用输入重定向符号(&lt;)时，Linux会用重定向指定的文件来替换标准输入文件描述符。 它会读取文件并提取数据，就如同它是键盘上键入的。 许多bash命令能接受STDIN的输入，尤其是没有在命令行上指定文件的话。下面是个用cat 命令处理STDIN输入的数据的例子。 $ cat this is a test this is a test this is a second test. this is a second test. 当在命令行上只输入cat命令时，它会从STDIN接受输入。输入一行，cat命令就会显示出 一行。但你也可以通过STDIN重定向符号强制cat命令接受来自另一个非STDIN文件的输入。 $ cat &lt; testfile This is the first line. This is the second line. This is the third line. 现在cat命令会用testfile文件中的行作为输入。你可以使用这种技术将数据输入到任何能从 STDIN接受数据的shell命令中。 ##二、STDOUT STDOUT文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。shell 的所有输出(包括shell中运行的程序和脚本)会被定向到标准输出中，也就是显示器。 默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。同时，你也可以用输出重定向来改变。 $ ls -l > test2 $ cat test2 total 20 -rw-rw-r-- 1 rich rich 53 2014-10-16 11:30 test -rw-rw-r-- 1 rich rich 0 2014-10-16 11:32 test2 -rw-rw-r-- 1 rich rich 73 2014-10-16 11:23 testfile 通过输出重定向符号，通常会显示到显示器的所有输出会被shell重定向到指定的重定向文件。你也可以将数据追加到某个文件。这可以用&gt;&gt;符号来完成。 $ who >> test2 $ cat test2 total 20 -rw-rw-r-- 1 rich rich 53 2014-10-16 11:30 test -rw-rw-r-- 1 rich rich 0 2014-10-16 11:32 test2 -rw-rw-r-- 1 rich rich 73 2014-10-16 11:23 testfile rich pts/0 2014-10-17 15:34 (192.168.1.2) $ who命令生成的输出会被追加到test2文件中已有数据的后面。 但是，如果你对脚本使用了标准输出重定向，你会遇到一个问题。下面的例子说明了可能会出现什么情况。 $ ls -al badfile > test3 ls: cannot access badfile: No such file or directory $ cat test3 当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重 定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。 shell对于错误消息的处理是跟普通输出分开的。如果你创建了在后台模式下运行的shell脚本，通常你必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。你需要换种方法来处理。 三、STDERR shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方(尽管分配给它们的文件描述符值不同)。也就是说，默认情况下，错误消息也会输出到显示器输出中。 但从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，你常常会想改变这种行为，尤其是当你希望将错误消息保存到日志文件中的时候。]]></content>
  </entry>
  <entry>
    <title><![CDATA[嵌入式Linux开发笔记 Linux环境搭建]]></title>
    <url>%2F2019%2F03%2F19%2Fpost-title%2F</url>
    <content type="text"><![CDATA[&lt;一&gt; Linux环境搭建 1.安装VMware Workstation虚拟机挂载： 它指将一个设备（通常是存储设备）挂接到一个已存在的目录上（这个目录可以不为空，但挂载后这个目录下以前的内容将不可用）我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。 2.安装ubuntu及相关服务2.1 安装编辑器VIMapt-get install vim 2.2 SSHD服务 ssh：Secure shell 分为客户端和服务端(1)安装SecureCRT客户端远程登录服务器(2)zmodem协议rz 命令(上传)以zmodem协议receivesz 命令（下载）以zmodem协议send rz命令以后出现选择文件框选择完以后输入rz命令可以查看文件输入ls命令可以查看根目录输入cat+文件名命令可以查看文件内容 上传下载例子： vi mytest.txt（创建文件） //输入编辑内容 :wq（保存退出） ls（查看目录） sz mytest.txt (下载文件) 2.3samba服务器简介：SMB 协议：Server Message Block（服务消息块）Linux模拟windows（SAMBA服务），与windows通讯 1.安装samba服务器apt-get install samba 2.samba服务器的配置（1）/etc/samba/smb.conf samba的用户权限： smbpasswd （命令） Linux 登录用户 Samba登录用户（用户名共享，密码不共享） 配置需要共享哪个目录，以及这个目录的访问权限 （2）配置samba访问权限及samba登录密码： cd /etc/samba （进入Samba文件夹） ls cp smb.conf bak_smb.conf（复制文件） ls sudo vi smb.conf（查看文件） 按i进入编辑模式 [lsc_share] comment=My share （标题） path=/home/lsc/lab （共享目录） writable=yes （是否可写） browseable=yes （是否可以浏览） public=yes guest ok=yes （客户是否连接） 按ESC退出编辑模式 :wq （保存退出命令） （3）/——-以下命令在 /etc/samba$ 下进行—————-/ -a（只能增加一个现有用户） sudo smbpasswd -a lsc New SMB password: 123 Retype new SMB password: 123 sudo /etc/init.d/smbd restart（重启） sudo /etc/init.d/nmbd restart（重启） 3.windows客户端的访问方式3.1在windows下创建虚拟共享目录：1.在Linux终端输入 ifconfig（查看IP地址） 2.windows下输入运行3.在 运行中输入 \IP地址（初始状态下弹出输入用户名和密码。为上面所设置的内容）4.查看共享目录发现没有（在Linux下输入以下命令） cd /home/lsc/ ls mkdir lab （创建目录） cd lab/ ls vi 123.txt //编辑内容（内容随意，用于测试） ：wq（保存退出） 5.再去看共享目录，发现有123.txt文件 3.2映射网络驱动器（盘符）： （相当于将Linux的共享盘当做U盘放在Windows当中的映射服务） 选择盘符（默认） \192.168.220.129\lsc_share(lsc_share为前面创建的分享目录)(地址通过ifcofig命令查看，共享文件为所创建的方括号内的名字) 建立一个文件（.txt），用于测试 在linux下输入cd ./lab ls cat abc.txt (查看文件) 4.vmtools的安装su （进入root用户） mkdir /mnt/cdrom (在mnt目录下创建cdrom文件夹，用于下一步使用) mount /dev/cdrom /mnt/cdrom （将光驱上的文件挂载在我们新建的文件夹里面） cd /mnt/cdrom（将操作目录切换到mnt目录下的cdrom文件夹里面） ls (查看后我们可以看到，VMware Tools工具被成功的放在了新建的文件夹下) cp VMwareTools-10.1.15-6627299.tar.gz /tmp（将VMwareTools压缩包复制到tmp目录下） cd /tmp（将操作目录切换到tmp目录下） tar -zxvf VMwareTools-10.1.15-6627299.tar.gz（将VMwareTools压缩包解压） sudo vmware-tools-distrib/vmware-install.pl 进行VMwareTools工具的安装。（注意安装的时候，不管出现什么，全部按enter键就行了） 完成安装后，我们重新启动我们的linux虚拟机，我们就会看到我们的共享文件夹了 cd /mnt ls cd hgfs/ 14. 点击设置里的选项中的共享文件夹 15.选择总是启用 16. 从Windows里选择一个文件夹，此文件夹相当于一个U盘一样存储Linux所建立的文件实现交互 ls (查看我们所建立的文件夹) tar命令扩展： tar -zxvf VMwareTools-10.1.15-6627299.tar.gz -C /tmp/ （将文件解压到tmp目录下） 5.SourceInsight安装代码编译器利器]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
